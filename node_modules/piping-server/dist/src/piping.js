"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Server = void 0;
const multiparty = __importStar(require("multiparty"));
const stream = __importStar(require("stream"));
const crypto = __importStar(require("crypto"));
const resources = __importStar(require("./resources"));
const version_1 = require("./version");
const reserved_paths_1 = require("./reserved-paths");
const utils = __importStar(require("./utils"));
class Http1_0SenderRes {
    constructor(res) {
        this.res = res;
        this.statusCodeAndHeaders = undefined;
        this.chunks = [];
    }
    writeHead(statusCode, headers) {
        this.statusCodeAndHeaders = { statusCode, headers };
    }
    write(chunk) {
        this.chunks.push(chunk);
    }
    end(chunk) {
        if (this.statusCodeAndHeaders === undefined) {
            throw new Error("statusCodeAndHeaders is not defined");
        }
        this.chunks.push(chunk);
        const body = this.chunks.join("");
        const { statusCode, headers } = this.statusCodeAndHeaders;
        this.res.writeHead(statusCode, Object.assign({ "Content-Length": Buffer.byteLength(body) }, headers));
        this.res.end(body);
    }
}
const senderAndReceiverMessageHeaders = {
    "Content-Type": "text/plain",
    "Access-Control-Allow-Origin": "*",
};
function resEndWithContentLength(res, statusCode, headers, body) {
    res.writeHead(statusCode, Object.assign({ "Content-Length": Buffer.byteLength(body) }, headers));
    res.end(body);
}
function forceHttp1_0StatusLine(res) {
    const socket = res.socket;
    const originalWrite = socket.write;
    socket.write = (chunk, ...rest) => {
        if (typeof chunk === "string") {
            const replaced = chunk.replace(/^HTTP\/1.1/, "HTTP/1.0");
            socket.write = originalWrite;
            return originalWrite.apply(socket, [replaced, ...rest]);
        }
        return originalWrite.apply(socket, [chunk, ...rest]);
    };
}
function getPipeIfEstablished(p) {
    if (p.sender !== undefined && p.receivers.length === p.nReceivers) {
        return {
            sender: {
                req: p.sender.req,
                resOrNotChunked: p.sender.resOrNotChunked,
            },
            receivers: p.receivers.map((r) => {
                r.unsubscribeCloseListener();
                return { req: r.req, res: r.res };
            })
        };
    }
    else {
        return undefined;
    }
}
class Server {
    static getNReceivers(reqUrl) {
        var _a;
        return parseInt((_a = reqUrl.searchParams.get('n')) !== null && _a !== void 0 ? _a : "1", 10);
    }
    constructor(params = {}) {
        this.params = params;
        this.pathToEstablished = new Set();
        this.pathToUnestablishedPipe = new Map();
    }
    generateHandler(useHttps) {
        return (req, res) => {
            var _a, _b;
            const reqUrl = new URL((_a = req.url) !== null && _a !== void 0 ? _a : "", "a:///");
            const reqPath = reqUrl.pathname;
            (_b = this.params.logger) === null || _b === void 0 ? void 0 : _b.info(`${req.method} ${req.url} HTTP/${req.httpVersion}`);
            if (req.httpVersion === "1.0") {
                forceHttp1_0StatusLine(res);
            }
            if ((0, reserved_paths_1.isReservedPath)(reqPath) && (req.method === "GET" || req.method === "HEAD")) {
                this.handleReservedPath(useHttps, req, res, reqPath, reqUrl);
                return;
            }
            switch (req.method) {
                case "POST":
                case "PUT":
                    if ((0, reserved_paths_1.isReservedPath)(reqPath)) {
                        resEndWithContentLength(res, 400, senderAndReceiverMessageHeaders, `[ERROR] Cannot send to the reserved path '${reqPath}'. (e.g. '/mypath123')\n`);
                        return;
                    }
                    if (req.headers["content-range"] !== undefined) {
                        resEndWithContentLength(res, 400, senderAndReceiverMessageHeaders, `[ERROR] Content-Range is not supported for now in ${req.method}\n`);
                        return;
                    }
                    this.handleSender(req, res, reqUrl);
                    break;
                case "GET":
                    this.handleReceiver(req, res, reqUrl);
                    break;
                case "OPTIONS":
                    res.writeHead(200, Object.assign(Object.assign({ "Access-Control-Allow-Origin": "*", "Access-Control-Allow-Methods": "GET, HEAD, POST, PUT, OPTIONS", "Access-Control-Allow-Headers": "Content-Type, Content-Disposition, X-Piping" }, (req.headers["access-control-request-private-network"] === "true" ? {
                        "Access-Control-Allow-Private-Network": "true",
                    } : {})), { "Access-Control-Expose-Headers": "Access-Control-Allow-Headers", "Access-Control-Max-Age": 86400, "Content-Length": 0 }));
                    res.end();
                    break;
                default:
                    resEndWithContentLength(res, 405, {
                        "Access-Control-Allow-Origin": "*",
                        "Allow": "GET, HEAD, POST, PUT, OPTIONS",
                    }, `[ERROR] Unsupported method: ${req.method}.\n`);
                    break;
            }
        };
    }
    handleReservedPath(useHttps, req, res, reqPath, reqUrl) {
        var _a;
        switch (reqPath) {
            case reserved_paths_1.NAME_TO_RESERVED_PATH.index:
                resEndWithContentLength(res, 200, {
                    "Content-Type": "text/html"
                }, resources.indexPage);
                return;
            case reserved_paths_1.NAME_TO_RESERVED_PATH.noscript: {
                const styleNonce = crypto.randomBytes(16).toString("base64");
                resEndWithContentLength(res, 200, {
                    "Content-Type": "text/html",
                    "Content-Security-Policy": `default-src 'none'; style-src 'nonce-${styleNonce}'`
                }, resources.noScriptHtml(reqUrl.searchParams, styleNonce));
                return;
            }
            case reserved_paths_1.NAME_TO_RESERVED_PATH.version:
                const versionPage = version_1.VERSION + "\n";
                resEndWithContentLength(res, 200, {
                    "Access-Control-Allow-Origin": "*",
                    "Content-Type": "text/plain"
                }, versionPage);
                return;
            case reserved_paths_1.NAME_TO_RESERVED_PATH.help:
                const xForwardedProtoIsHttps = (() => {
                    const proto = req.headers["x-forwarded-proto"];
                    return proto !== undefined && proto.includes("https");
                })();
                const scheme = (useHttps || xForwardedProtoIsHttps) ? "https" : "http";
                const hostname = (_a = req.headers.host) !== null && _a !== void 0 ? _a : "hostname";
                const url = `${scheme}://${hostname}`;
                const helpPage = resources.generateHelpPage(url);
                resEndWithContentLength(res, 200, {
                    "Access-Control-Allow-Origin": "*",
                    "Content-Type": "text/plain"
                }, helpPage);
                return;
            case reserved_paths_1.NAME_TO_RESERVED_PATH.faviconIco:
                res.writeHead(204);
                res.end();
                break;
            case reserved_paths_1.NAME_TO_RESERVED_PATH.robotsTxt:
                res.writeHead(404, {
                    "Content-Length": 0,
                });
                res.end();
                return;
        }
    }
    runPipe(path, pipe) {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            this.pathToEstablished.add(path);
            this.pathToUnestablishedPipe.delete(path);
            const { sender, receivers } = pipe;
            sender.resOrNotChunked.write(`[INFO] Start sending to ${pipe.receivers.length} receiver(s)!\n`);
            (_a = this.params.logger) === null || _a === void 0 ? void 0 : _a.info(`Sending: path='${path}', receivers=${pipe.receivers.length}`);
            const isMultipart = ((_b = sender.req.headers["content-type"]) !== null && _b !== void 0 ? _b : "").includes("multipart/form-data");
            const part = isMultipart ?
                yield new Promise((resolve, reject) => {
                    const form = new multiparty.Form();
                    form.once("part", (p) => {
                        resolve(p);
                    });
                    form.on("error", () => {
                        var _a;
                        (_a = this.params.logger) === null || _a === void 0 ? void 0 : _a.info(`sender-multipart on-error: '${path}'`);
                    });
                    form.parse(sender.req);
                }) :
                undefined;
            const senderData = part === undefined ? sender.req : part;
            let abortedCount = 0;
            let endCount = 0;
            for (const receiver of receivers) {
                const abortedListener = () => {
                    abortedCount++;
                    sender.resOrNotChunked.write("[INFO] A receiver aborted.\n");
                    senderData.unpipe(passThrough);
                    if (abortedCount === receivers.length) {
                        sender.resOrNotChunked.end("[INFO] All receiver(s) was/were aborted halfway.\n");
                        this.removeEstablished(path);
                        sender.req.destroy();
                    }
                };
                const endListener = () => {
                    endCount++;
                    if (endCount === receivers.length) {
                        sender.resOrNotChunked.end("[INFO] All receiver(s) was/were received successfully.\n");
                        this.removeEstablished(path);
                    }
                };
                const contentLength = part === undefined ?
                    sender.req.headers["content-length"] : part.byteCount;
                const contentType = (() => {
                    const type = (part === undefined ?
                        sender.req.headers["content-type"] : part.headers["content-type"]);
                    if (type === undefined) {
                        return undefined;
                    }
                    const matched = type.match(/^\s*([^;]*)(\s*;?.*)$/);
                    if (matched === null) {
                        return undefined;
                    }
                    else {
                        const mimeType = matched[1];
                        const params = matched[2];
                        return mimeType === "text/html" ? "text/plain" + params : type;
                    }
                })();
                const contentDisposition = part === undefined ?
                    sender.req.headers["content-disposition"] : part.headers["content-disposition"];
                const parseHeaders = utils.parseHeaders(sender.req.rawHeaders);
                const xPiping = (_c = parseHeaders.get("x-piping")) !== null && _c !== void 0 ? _c : [];
                receiver.res.writeHead(200, Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, (contentLength === undefined ? {} : { "Content-Length": contentLength })), (contentType === undefined ? {} : { "Content-Type": contentType })), (contentDisposition === undefined ? {} : { "Content-Disposition": contentDisposition })), { "X-Piping": xPiping, "Access-Control-Allow-Origin": "*" }), (xPiping.length === 0 ? {} : { "Access-Control-Expose-Headers": "X-Piping" })), { "X-Robots-Tag": "none" }));
                const passThrough = new stream.PassThrough();
                senderData.pipe(passThrough);
                passThrough.pipe(receiver.res);
                receiver.req.on("end", () => {
                    var _a;
                    (_a = this.params.logger) === null || _a === void 0 ? void 0 : _a.info(`receiver on-end: '${path}'`);
                    endListener();
                });
                receiver.req.on("close", () => {
                    var _a;
                    (_a = this.params.logger) === null || _a === void 0 ? void 0 : _a.info(`receiver on-close: '${path}'`);
                });
                receiver.req.on("aborted", () => {
                    var _a;
                    (_a = this.params.logger) === null || _a === void 0 ? void 0 : _a.info(`receiver on-aborted: '${path}'`);
                    abortedListener();
                });
                receiver.req.on("error", (err) => {
                    var _a;
                    (_a = this.params.logger) === null || _a === void 0 ? void 0 : _a.info(`receiver on-error: '${path}'`);
                    abortedListener();
                });
            }
            senderData.on("close", () => {
                var _a;
                (_a = this.params.logger) === null || _a === void 0 ? void 0 : _a.info(`sender on-close: '${path}'`);
            });
            senderData.on("aborted", () => {
                var _a;
                for (const receiver of receivers) {
                    if (receiver.res.connection !== undefined && receiver.res.connection !== null) {
                        receiver.res.connection.destroy();
                    }
                }
                (_a = this.params.logger) === null || _a === void 0 ? void 0 : _a.info(`sender on-aborted: '${path}'`);
            });
            senderData.on("end", () => {
                var _a;
                sender.resOrNotChunked.write("[INFO] Sent successfully!\n");
                (_a = this.params.logger) === null || _a === void 0 ? void 0 : _a.info(`sender on-end: '${path}'`);
            });
            senderData.on("error", (error) => {
                var _a;
                sender.resOrNotChunked.end("[ERROR] Failed to send.\n");
                this.removeEstablished(path);
                (_a = this.params.logger) === null || _a === void 0 ? void 0 : _a.info(`sender on-error: '${path}'`);
            });
        });
    }
    removeEstablished(path) {
        var _a;
        this.pathToEstablished.delete(path);
        (_a = this.params.logger) === null || _a === void 0 ? void 0 : _a.info(`established '${path}' removed`);
    }
    handleSender(req, res, reqUrl) {
        const reqPath = reqUrl.pathname;
        const nReceivers = Server.getNReceivers(reqUrl);
        if (Number.isNaN(nReceivers)) {
            resEndWithContentLength(res, 400, senderAndReceiverMessageHeaders, `[ERROR] Invalid "n" query parameter\n`);
            return;
        }
        if (nReceivers <= 0) {
            resEndWithContentLength(res, 400, senderAndReceiverMessageHeaders, `[ERROR] n should > 0, but n = ${nReceivers}.\n`);
            return;
        }
        if (this.pathToEstablished.has(reqPath)) {
            resEndWithContentLength(res, 400, senderAndReceiverMessageHeaders, `[ERROR] Connection on '${reqPath}' has been established already.\n`);
            return;
        }
        const unestablishedPipe = this.pathToUnestablishedPipe.get(reqPath);
        if (unestablishedPipe === undefined) {
            const sender = this.createSenderOrReceiver("sender", req, res, reqPath);
            this.pathToUnestablishedPipe.set(reqPath, {
                sender: sender,
                receivers: [],
                nReceivers: nReceivers
            });
            sender.resOrNotChunked.writeHead(200, senderAndReceiverMessageHeaders);
            sender.resOrNotChunked.write(`[INFO] Waiting for ${nReceivers} receiver(s)...\n`);
            return;
        }
        if (unestablishedPipe.sender !== undefined) {
            resEndWithContentLength(res, 400, senderAndReceiverMessageHeaders, `[ERROR] Another sender has been connected on '${reqPath}'.\n`);
            return;
        }
        if (nReceivers !== unestablishedPipe.nReceivers) {
            resEndWithContentLength(res, 400, senderAndReceiverMessageHeaders, `[ERROR] The number of receivers should be ${unestablishedPipe.nReceivers} but ${nReceivers}.\n`);
            return;
        }
        unestablishedPipe.sender = this.createSenderOrReceiver("sender", req, res, reqPath);
        unestablishedPipe.sender.resOrNotChunked.writeHead(200, senderAndReceiverMessageHeaders);
        unestablishedPipe.sender.resOrNotChunked.write(`[INFO] Waiting for ${nReceivers} receiver(s)...\n`);
        unestablishedPipe.sender.resOrNotChunked.write(`[INFO] ${unestablishedPipe.receivers.length} receiver(s) has/have been connected.\n`);
        const pipe = getPipeIfEstablished(unestablishedPipe);
        if (pipe !== undefined) {
            this.runPipe(reqPath, pipe);
        }
    }
    handleReceiver(req, res, reqUrl) {
        const reqPath = reqUrl.pathname;
        if (req.headers["service-worker"] === "script") {
            resEndWithContentLength(res, 400, senderAndReceiverMessageHeaders, `[ERROR] Service Worker registration is rejected.\n`);
            return;
        }
        const nReceivers = Server.getNReceivers(reqUrl);
        if (Number.isNaN(nReceivers)) {
            resEndWithContentLength(res, 400, senderAndReceiverMessageHeaders, `[ERROR] Invalid query parameter "n"\n`);
            return;
        }
        if (nReceivers <= 0) {
            resEndWithContentLength(res, 400, senderAndReceiverMessageHeaders, `[ERROR] n should > 0, but n = ${nReceivers}.\n`);
            return;
        }
        if (this.pathToEstablished.has(reqPath)) {
            resEndWithContentLength(res, 400, senderAndReceiverMessageHeaders, `[ERROR] Connection on '${reqPath}' has been established already.\n`);
            return;
        }
        const unestablishedPipe = this.pathToUnestablishedPipe.get(reqPath);
        if (unestablishedPipe === undefined) {
            const receiver = this.createSenderOrReceiver("receiver", req, res, reqPath);
            this.pathToUnestablishedPipe.set(reqPath, {
                receivers: [receiver],
                nReceivers: nReceivers
            });
            return;
        }
        if (nReceivers !== unestablishedPipe.nReceivers) {
            resEndWithContentLength(res, 400, senderAndReceiverMessageHeaders, `[ERROR] The number of receivers should be ${unestablishedPipe.nReceivers} but ${nReceivers}.\n`);
            return;
        }
        if (unestablishedPipe.receivers.length === unestablishedPipe.nReceivers) {
            resEndWithContentLength(res, 400, senderAndReceiverMessageHeaders, "[ERROR] The number of receivers has reached limits.\n");
            return;
        }
        const receiver = this.createSenderOrReceiver("receiver", req, res, reqPath);
        unestablishedPipe.receivers.push(receiver);
        if (unestablishedPipe.sender !== undefined) {
            unestablishedPipe.sender.resOrNotChunked.write("[INFO] A receiver was connected.\n");
        }
        const pipe = getPipeIfEstablished(unestablishedPipe);
        if (pipe !== undefined) {
            this.runPipe(reqPath, pipe);
        }
    }
    createSenderOrReceiver(reqResType, req, res, reqPath) {
        const closeListener = () => {
            var _a;
            const unestablishedPipe = this.pathToUnestablishedPipe.get(reqPath);
            if (unestablishedPipe !== undefined) {
                const remover = reqResType === "sender" ?
                    () => {
                        if (unestablishedPipe.sender !== undefined) {
                            unestablishedPipe.sender = undefined;
                            return true;
                        }
                        return false;
                    } :
                    () => {
                        const receivers = unestablishedPipe.receivers;
                        const idx = receivers.findIndex((r) => r.req === req);
                        if (idx !== -1) {
                            receivers.splice(idx, 1);
                            return true;
                        }
                        return false;
                    };
                const removed = remover();
                if (removed) {
                    if (unestablishedPipe.receivers.length === 0 && unestablishedPipe.sender === undefined) {
                        this.pathToUnestablishedPipe.delete(reqPath);
                        (_a = this.params.logger) === null || _a === void 0 ? void 0 : _a.info(`unestablished '${reqPath}' removed`);
                    }
                }
            }
        };
        req.once("close", closeListener);
        const unsubscribeCloseListener = () => {
            req.removeListener("close", closeListener);
        };
        if (reqResType === "sender" && req.httpVersion === "1.0") {
            return {
                req: req,
                resOrNotChunked: new Http1_0SenderRes(res),
                unsubscribeCloseListener,
            };
        }
        if (reqResType === "sender") {
            return {
                req: req,
                resOrNotChunked: res,
                unsubscribeCloseListener,
            };
        }
        return {
            req: req,
            res: res,
            unsubscribeCloseListener,
        };
    }
}
exports.Server = Server;
//# sourceMappingURL=piping.js.map